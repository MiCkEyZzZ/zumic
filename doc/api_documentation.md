# Zumic API документация

## Общая информация

Zumic — это хранилище данных, поддерживающее различные типы данных, включая строки, целые числа, числа с плавающей точкой, списки, хэши, множества и отсортированные множества. Он предоставляет API для выполнения операций с этими типами данных, такие как добавление, удаление, чтение, получение ранга, балла и так далее.

## Структура проекта

### command

Это каталог содержит модули, реализующие команды для взаимодействия с данными в хранилище. Команды разделены по типам данных, с которыми они работают.

- `basic.rs`: Основные команды (например, для работы с ключами).
- `command.rs`: Общая логика выполнения команд.
- `error.rs`: Определения ошибок.
- `execute.rs`: Логика выполнения команд.
- `float.rs`: Команды для работы с числами с плавающей точкой.
- `hash.rs`: Команды для работы с хэшами.
- `int.rs`: Команды для работы с целыми числами.
- `list.rs`: Команды для работы со списками.
- `set.rs`: Команды для работы с множествами.
- `string.rs`: Команды для работы со строками.
- `zset.rs`: Команды для работы с отсортированными множествами.

### storage

Содержит логику хранилища данных, включая:

- `persistence/aof.rs`: Реализация записи и чтения команд в формате AOF (Append-Only File).
- `persistence/snapshot.rs`: Механизм снимков хранилища.
- `aof.rs`: Основной код для работы с AOF.
- `store.rs`: Логика работы с основным хранилищем.
- `ttl.rs`: Обработка времени жизни данных.
- `types.rs`: Определения типов данных, поддерживаемых хранилищем.

### network

Модуль для реализации сетевого взаимодействия:

- `client.rs`: Логика клиента.
- `protocol.rs`: Протокол для взаимодействия с сервером.
- `server.rs`: Логика сервера.

### pubsub

Модуль для обработки подписки и публикации сообщений:

- `manager.rs`: Логика управления подписками.
- `subscriber.rs`: Логика подписчиков.

### config

Содержит настройки конфигурации проекта.

### engine

Основной движок обработки команд и выполнения логики.

### tests

Тесты для различных компонентов системы, включая:

- `network_test.rs`: Тесты для сетевого взаимодействия.

### benches

- `bench`: Тесты производительности.


## Команды API

### 1. `ZAddCommand`
Добавляет элемент с определённым баллом в отсортированное множество.

**Параметры:**
- `key` — Ключ для отсортированного множества.
- `score` — Балл, с которым элемент добавляется.
- `member` — Элемент, добавляемый в множество.

**Ответ:**
- `Value::Int(1)` — если элемент был успешно добавлен.
- `Value::Int(0)` — если элемент с таким баллом уже существует.

### 2. `ZRemCommand`
Удаляет элемент из отсортированного множества.

**Параметры:**
- `key` — Ключ для отсортированного множества.
- `member` — Элемент, который нужно удалить.

**Ответ:**
- `Value::Int(1)` — если элемент был успешно удалён.
- `Value::Int(0)` — если элемент не найден.

### 3. `ZRankCommand`
Возвращает ранг элемента в отсортированном множестве.

**Параметры:**
- `key` — Ключ для отсортированного множества.
- `member` — Элемент для поиска ранга.

**Ответ:**
- `Value::Int(rank)` — ранг элемента в множестве.
- `CommandError::KeyNotFound` — если элемент не найден.

### 4. `ZScoreCommand`
Возвращает балл элемента в отсортированном множестве.

**Параметры:**
- `key` — Ключ для отсортированного множества.
- `member` — Элемент для поиска его балла.

**Ответ:**
- `Value::Float(score)` — балл элемента.
- `CommandError::KeyNotFound` — если элемент не найден.

### 5. `ZCardCommand`
Возвращает количество элементов в отсортированном множестве.

**Параметры:**
- `key` — Ключ для отсортированного множества.

**Ответ:**
- `Value::Int(count)` — количество элементов в множестве.

## Пример использования

### Создание и добавление элементов в отсортированное множество:

```rust
let store: Store<String> = Store::new();

let zadd_command = ZAddCommand {
    key: "my_zset".to_string(),
    score: 10.5,
    member: "Anton".to_string(),
};
zadd_command.execute(&store);

let zcard_command = ZCardCommand {
    key: "my_zset".to_string(),
};
let result = zcard_command.execute(&store);
println!("{:?}", result); // Output: Ok(Value::Int(1))
```

### Удаление элемента из отсортированного множества:

```rust
let zrem_command = ZRemCommand {
    key: "my_zset".to_string(),
    member: "Anton".to_string(),
};
let result = zrem_command.execute(&store);
println!("{:?}", result); // Output: Ok(Value::Int(1))
```

## Сетевые взаимодействия

Zumic поддерживает сетевые взаимодействия через протокол, описанный в файле `protocol.rs`. С помощью этого API можно взаимодействовать с сервером, посылая команды и получая ответы.

## Заключение

API Zumic предоставляет удобный интерфейс для работы с различными типами данных в хранилище. Его легко интегрировать с внешними системами, а структура проекта позволяет легко расширять функциональность.


Эта документация представляет собой общий обзор API и структуры проекта. Вы можете дополнительно адаптировать её, уточнив детали и добавив дополнительные примеры в зависимости от изменений в коде или новых команд.
