# **Skip Lists: вероятностная альтернатива сбалансированным деревьям**

> Пропускные списки (Skip Lists) — это структура данных, которая может использоваться вместо сбалансированных деревьев.
> Пропускные списки используют вероятностное балансирование, а не строгое принудительное, и в результате алгоритмы вставки и удаления в пропускных списках **намного проще** и **значительно быстрее**, чем эквивалентные алгоритмы для сбалансированных деревьев.

## **Уильям Паг**

Двоичные деревья могут использоваться для представления абстрактных типов данных, таких как словари и упорядоченные списки. Они хорошо работают, когда элементы вставляются в случайном порядке. Некоторые последовательности операций, например вставка элементов по порядку, порождают дегенеративные структуры данных, которые демонстрируют очень плохую производительность. Если бы было возможно случайным образом переставить список элементов, предназначенных для вставки, деревья с высокой вероятностью работали бы хорошо для любой входной последовательности. В большинстве случаев запросы должны обрабатываться онлайн, поэтому случайная перестановка входных данных непрактична. Алгоритмы сбалансированных деревьев перестраивают дерево по мере выполнения операций, чтобы поддерживать определённые условия баланса и обеспечивать хорошую производительность.

Пропускные списки являются вероятностной альтернативой сбалансированным деревьям. Пропускные списки балансируются с помощью генератора случайных чисел. Хотя пропускные списки имеют плохую производительность в худшем случае, ни одна входная последовательность последовательно не вызывает худший случай (похоже на быструю сортировку, когда опорный элемент выбирается случайно). Очень маловероятно, что структура данных skip list будет сильно несбалансированной (например, для словаря из более чем 250 элементов вероятность того, что поиск займёт более чем в 3 раза больше времени, чем ожидаемое, меньше одной на миллион).

Пропускные списки обладают свойствами баланса, аналогичными деревьям поиска, построенным случайными вставками, но при этом не требуют, чтобы вставки были случайными. Балансировка структуры данных вероятностным образом проще, чем явное поддержание баланса. Для многих приложений пропускные списки являются более естественным представлением, чем деревья, что также ведёт к более простым алгоритмам. Простота алгоритмов пропускных списков облегчает их реализацию и обеспечивает значительное ускорение по константному фактору по сравнению с алгоритмами сбалансированных деревьев и самонастраивающихся деревьев. Пропускные списки также очень эффективны по использованию памяти. Их легко настроить так, чтобы в среднем требовался 1⅓ указателя на элемент (или даже меньше), и при этом нет необходимости хранить информацию о балансе или приоритетах в каждом узле.

## **Пропускные списки**

При поиске в связном списке нам может понадобиться проверить каждый узел списка (Рисунок 1a). Если список хранится в отсортированном порядке, и каждый второй узел списка также имеет указатель на узел через один (Рисунок 1b), нам придётся проверить не более чем ⌈n/2⌉ + 1 узлов (где n — длина списка). Если каждому четвёртому узлу дать указатель через три узла (Рисунок 1c), потребуется проверить не более чем ⌈n/4⌉ + 2 узлов.

Если каждый (2^i)-й узел имеет указатель на 2^i узлов вперёд (Рисунок 1d), количество проверяемых узлов может быть сокращено до ⌈log₂ n⌉ при удвоении количества указателей. Такая структура данных могла бы использоваться для быстрого поиска, но вставка и удаление были бы непрактичными.

Узел, имеющий k forward-указателей, называется узлом уровня k. Если каждый (2^i)-й узел имеет указатель на 2^i узлов вперёд, уровни узлов распределяются по простой схеме: 50% — уровень 1, 25% — уровень 2, 12,5% — уровень 3 и так далее. Что произойдёт, если уровни узлов выбрать случайным образом, но в тех же пропорциях (например, как на Рисунке 1e)? i-й forward-указатель узла, вместо того чтобы указывать на 2^i–1 узлов вперёд, указывает на следующий узел уровня i или выше. Вставка или удаление потребуют только локальных изменений; уровень узла, выбранный случайным образом при вставке, никогда не изменяется. Некоторые распределения уровней могут дать плохое время выполнения, но мы увидим, что такие распределения встречаются редко. Поскольку эти структуры данных являются связанными списками с дополнительными указателями, которые перескакивают через промежуточные узлы, я назвал их **пропускными списками**.

## **Алгоритмы пропускных списков**

В этом разделе описаны алгоритмы поиска, вставки и удаления элементов в словаре или таблице символов. Операция **Search** возвращает значение, связанное с нужным ключом, или сообщает об отсутствии ключа. Операция **Insert** связывает указанный ключ с новым значением (вставляя ключ, если он ещё не присутствовал). Операция **Delete** удаляет заданный ключ. Легко поддерживать дополнительные операции, такие как «найти минимальный ключ» или «найти следующий ключ».

Каждый элемент представлен узлом, уровень которого выбирается случайным образом при вставке, независимо от количества элементов в структуре. Узел уровня i имеет i forward-указателей, индексированных от 1 до i. Нет необходимости хранить уровень узла внутри самого узла. Уровни ограничены некоторой подходящей константой MaxLevel. Уровень списка — это максимальный уровень на данный момент (или 1, если список пуст). Заголовок списка имеет forward-указатели на уровнях от 1 до MaxLevel. Forward-указатели заголовка на уровнях выше текущего максимального уровня списка указывают на NIL.

![РИСУНОК 1 - Связанные списки с дополнительными указателями](images/figure_1.png)

### **Инициализация**

Выделяется элемент NIL и ему присваивается ключ, больший, чем любой допустимый ключ. Все уровни всех пропускных списков завершаются NIL. Новый список инициализируется так, что уровень списка равен 1, а все forward-указатели заголовка списка указывают на NIL.

### **Алгоритм поиска**

Мы ищем элемент, перемещаясь по forward-указателям так, чтобы не «перепрыгнуть» узел, содержащий искомый элемент (Рисунок 2). Когда на текущем уровне forward-указателей невозможно продвинуться дальше, поиск переходит на следующий уровень вниз. Когда на уровне 1 невозможно сделать больше шагов, мы должны оказаться непосредственно перед узлом, который содержит нужный элемент (если он присутствует в списке).

### **Алгоритмы вставки и удаления**

Для вставки или удаления узла мы просто выполняем поиск и «вшиваем» узел, как показано на Рисунке 3. На Рисунке 4 приведены алгоритмы для вставки и удаления. Поддерживается вектор **update**, так что после завершения поиска (и когда мы готовы выполнить вставку или удаление) `update[i]` содержит указатель на самый правый узел уровня i или выше, который находится слева от позиции вставки/удаления.

![РИСУНОК 2 - Алгоритм поиска по списку с пропусками](images/figure_2.png)

Если вставка создаёт узел с уровнем, большим, чем предыдущий максимальный уровень списка, мы обновляем максимальный уровень списка и инициализируем соответствующие части вектора **update**. После каждого удаления проверяется, удалён ли максимальный элемент списка; если да, максимальный уровень списка уменьшается.

### **Выбор случайного уровня**

Изначально мы обсуждали распределение вероятностей, при котором половина узлов с указателями уровня i также имеет указатели уровня i+1. Чтобы отказаться от «магических констант», мы говорим, что доля **p** узлов с указателями уровня i также имеет указатели уровня i+1 (для нашего первоначального обсуждения p = 1/2). Уровни генерируются случайным образом алгоритмом, эквивалентным показанному на Рисунке 5. Уровни генерируются без учета количества элементов в списке.

### **На каком уровне начинать поиск? Определение L(n)**

В пропускном списке из 16 элементов с p = 1/2 может получиться, что 9 элементов — уровня 1, 3 элемента — уровня 2, 3 элемента — уровня 3 и 1 элемент — уровня 14 (это очень маловероятно, но возможно). Как с этим справиться? Если мы используем стандартный алгоритм и начнем поиск на уровне 14, мы выполним много лишней работы.

Где следует начинать поиск? Наш анализ показывает, что оптимально начинать поиск на уровне L, где ожидается 1/p узлов. Это происходит, когда L = log₁/ₚ n. Поскольку мы будем часто обращаться к этой формуле, мы будем обозначать L(n) как log₁/ₚ n.

Существует несколько решений для случая, когда в списке есть элемент с необычно большим уровнем:

- Не переживайте, будьте счастливы. Просто начинайте поиск на самом высоком уровне, присутствующем в списке. Как мы увидим в анализе, вероятность того, что максимальный уровень в списке из n элементов значительно больше L(n), очень мала. Начало поиска с максимального уровня списка добавляет лишь небольшую константу к ожидаемому времени поиска. Именно такой подход используется в алгоритмах, описанных в этой статье.

![РИСУНОК 3 - Схематическое описание этапов выполнения введения](images/figure_3.png)

• **Использовать меньше, чем дано.** Хотя элемент может содержать место для 14 указателей, нам не обязательно использовать все 14. Мы можем выбрать использование только L(n) уровней. Существует несколько способов реализовать это, однако все они усложняют алгоритмы и не дают заметного улучшения производительности, поэтому данный подход не рекомендуется.

• **Подправить кости.** Если мы генерируем случайный уровень, который более чем на единицу превышает текущий максимальный уровень списка, мы просто используем значение, равное текущему максимальному уровню списка плюс один, в качестве уровня нового узла. На практике и интуитивно это изменение кажется работающим хорошо. Однако оно полностью разрушает нашу возможность анализировать получающиеся алгоритмы, поскольку уровень узла больше не является полностью случайным. Программисты, вероятно, могут свободно реализовывать это, но пуристы должны этого избегать.

### **Определение MaxLevel**

Поскольку мы можем безопасно ограничить уровни значением L(n), следует выбирать MaxLevel = L(N) (где N — верхняя граница числа элементов в пропускном списке). Если p = 1/2, использование MaxLevel = 16 является подходящим для структур данных, содержащих до 2¹⁶ элементов.

## **АНАЛИЗ АЛГОРИТМОВ ПРОПУСКНЫХ СПИСКОВ**

Время, необходимое для выполнения операций Search, Delete и Insert, определяется в основном временем, требуемым для поиска соответствующего элемента. Для операций Insert и Delete существует дополнительная стоимость, пропорциональная уровню вставляемого или удаляемого узла. Время, необходимое для нахождения элемента, пропорционально длине пути поиска, которая определяется тем, в каком порядке элементы разных уровней встречаются при обходе списка.

### **Вероятностная философия**

Структура пропускного списка определяется только количеством

![РИСУНОК 4 - Алгоритмы вставки и удаления в списке Skip List](images/figure_4.png)

![РИСУНОК 5 - Алгоритм расчета случайного уровня](images/figure_5.png)

элементов в пропускном списке и результатами обращения к генератору случайных чисел. Последовательность операций, которая привела к текущему состоянию пропускного списка, не имеет значения. Мы предполагаем, что враждебный пользователь не имеет доступа к уровням узлов; в противном случае он мог бы создавать ситуации с худшим временем выполнения, удаляя все узлы, которые не имеют уровня 1.

Вероятности плохих времен выполнения для последовательных операций над одной и той же структурой данных НЕ являются независимыми; два последовательных поиска одного и того же элемента займут совершенно одинаковое время. Позже об этом будет сказано больше.

### **Анализ ожидаемой стоимости поиска**

Мы анализируем путь поиска в обратном направлении, двигаясь вверх и влево. Хотя уровни узлов в списке известны и фиксированы в момент выполнения поиска, мы ведем себя так, как будто уровень узла определяется только тогда, когда он наблюдается при обратном проходе по пути поиска.

В любой конкретный момент подъема мы находимся в ситуации, аналогичной ситуации a на Рисунке 6 — мы находимся у i-го forward-указателя узла x и не имеем информации об уровнях узлов слева от x или об уровне самого x, кроме того, что уровень x должен быть не меньше i. Предположим, что x не является заголовком (это эквивалентно предположению, что список бесконечно продолжается влево). Если уровень x равен i, то мы находимся в ситуации b. Если уровень x больше i, то мы находимся в ситуации c. Вероятность того, что мы находимся в ситуации c, равна p. Каждый раз, когда мы находимся в ситуации c, мы поднимаемся на один уровень вверх.

Пусть C(k) = ожидаемая стоимость (то есть длина) пути поиска, который поднимается на k уровней в бесконечном списке:

C(0) = 0
C(k) = (1–p) (стоимость в ситуации b) + p (стоимость в ситуации c)

Подставляя и упрощая, получаем:

C(k) = (1–p) (1 + C(k)) + p (1 + C(k–1))
C(k) = 1/p + C(k–1)
C(k) = k/p

Наше предположение о бесконечности списка является пессимистическим. Когда при обратном подъеме мы упираемся в заголовок, мы просто поднимаемся вверх по нему, не выполняя никаких движений влево. Это дает нам верхнюю границу (L(n)–1)/p для ожидаемой длины пути, который поднимается с уровня 1 до уровня L(n) в списке из n элементов.

Мы используем этот анализ до уровня L(n), а для оставшейся части пути применяем другую технику анализа. Число оставшихся перемещений влево ограничено количеством элементов уровня L(n) или выше во всем списке, которое имеет ожидаемое значение 1/p.

Мы также поднимаемся вверх от уровня L(n) до максимального уровня в списке. Вероятность того, что максимальный уровень списка больше k, равна 1–(1–pᵏ)ⁿ, что не превышает npᵏ. Можно вычислить, что ожидаемый максимальный уровень не превышает L(n) + 1/(1–p). Объединяя результаты, получаем:

Общая ожидаемая стоимость выхода из списка из n элементов
≤ L(n)/p + 1/(1–p)

что равно O(log n).

### **Число сравнений**

Наш результат является анализом «длины» пути поиска. Число требуемых сравнений равно единице плюс длина пути поиска (сравнение выполняется в каждой позиции пути поиска, а «длина» пути поиска — это число переходов между позициями на пути поиска).

### **Вероятностный анализ**

Также возможно проанализировать распределение вероятностей стоимости поиска. Вероятностный анализ несколько более сложен (см. вставку). Из вероятностного анализа можно вычислить верхнюю границу вероятности того, что фактическая стоимость поиска превышает ожидаемую более чем на заданное отношение. Некоторые результаты этого анализа показаны на Рисунке 8.

### **Выбор p**

В Таблице 1 приведены относительные времена и требования к памяти для различных значений p. Уменьшение p также увеличивает вариативность времени выполнения. Если 1/p является степенью 2, будет легко генерировать случайный уровень из потока случайных битов (для генерации случайного уровня в среднем требуется (log₂ 1/p)/(1–p) случайных бит). Поскольку некоторые постоянные накладные расходы связаны с L(n) (а не с L(n)/p), выбор p = 1/4 (вместо 1/2) немного улучшает постоянные множители скорости алгоритмов. Я предлагаю использовать значение 1/4 для p, если только вариативность времени выполнения не является основным требованием; в этом случае следует использовать p = 1/2.

![РИСУНОК 6 - Возможные ситуации при обратном прохождении пути поиска](images/figure_6.png)

### **Последовательности операций**

Ожидаемое общее время для последовательности операций равно сумме ожидаемых времен каждой из операций в последовательности. Таким образом, ожидаемое время для любой последовательности из m поисков в структуре данных, содержащей n элементов, равно O(m log n). Однако характер (паттерн) поисков влияет на распределение вероятностей фактического времени выполнения всей последовательности операций.

Если мы дважды ищем один и тот же элемент в одной и той же структуре данных, оба поиска займут совершенно одинаковое время. Следовательно, дисперсия общего времени будет в четыре раза больше дисперсии одного поиска. Если времена поиска для двух элементов независимы, дисперсия общего времени равна сумме дисперсий отдельных поисков.

Повторный поиск одного и того же элемента снова и снова максимизирует дисперсию.
